package org.firstinspires.ftc.teamcode.Teleop;

import com.qualcomm.robotcore.eventloop.opmode.*;
import com.qualcomm.robotcore.hardware.*;
import android.graphics.Color;

import com.acmerobotics.dashboard.FtcDashboard;
import com.acmerobotics.dashboard.telemetry.MultipleTelemetry;
import com.acmerobotics.dashboard.config.Config;

import com.qualcomm.hardware.rev.RevColorSensorV3;
import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
import org.firstinspires.ftc.vision.VisionPortal;
import org.firstinspires.ftc.vision.apriltag.AprilTagProcessor;
import org.firstinspires.ftc.vision.apriltag.AprilTagDetection;

import java.util.List;

enum SpindexMode { INTAKE, OUTTAKE }

enum ShooterState {
    IDLE,
    ARM_FIRST_SLOT,
    PRE_SHOT_DELAY,
    MOVE_TO_SLOT,
    WAIT_FOR_SPINDEX,
    SERVO_OUT,
    SERVO_IN
}

@Config
class ShooterConfig {
    // RPM presets
    public static double RPM_PRESET_A = 3400;  // Trigger
    public static double RPM_PRESET_B = 4200;  // Left bumper

    // Hood positions per preset
    public static double HOOD_PRESET_A = 0.22;
    public static double HOOD_PRESET_B = 0.34;

    // Bang-bang threshold
    public static double bangBangRPM = 700;

    // PID constants
    public static double kP = 0.0012;
    public static double kI = 0.00025;
    public static double kD = 0.00008;

    // Max motor power
    public static double maxPower = 1.0;
}

// ===== TELEOP CLASS =====
@TeleOp(name = "TeleOp Shooter FSM Complete", group = "Linear OpMode")
public class Drive extends LinearOpMode {

    // ===== HARDWARE =====
    DcMotor FL, FR, BL, BR;
    DcMotorEx Shooter1, Shooter2, Intake;
    Servo Transfer, Hood, Spin;
    RevColorSensorV3 colorSensor;

    // ===== CONSTANTS =====
    static final double TICKS_PER_REV = 28.0;
    static final double GEAR_RATIO = 1.0;

    static final double[] SPINDEX_SLOTS = {0.0, 0.45, 0.93, 0.70, 0.23};
    static final int[] INTAKE_SLOTS = {0, 1, 2};
    static final int[] OUTTAKE_SLOTS = {3, 4};

    static final long SLOT_MOVE_DELAY = 400;
    static final long PRE_SHOT_DELAY = 500;
    static final double SERVO_OUT = 0.5;
    static final double SERVO_IN = 0.0;
    static final long SERVO_OUT_TIME = 420;
    static final long WAIT_BETWEEN_SHOTS = 460;

    // ===== SPINDEX + FSM =====
    SpindexController spindex;
    ShooterFSM shooterFSM;

    boolean lastA = false;
    boolean lastDetectedBall = false;

    double shooterIntegral = 0;
    double shooterLastError = 0;
    long shooterLastTime = 0;

    // ===== CAMERA =====
    VisionPortal visionPortal;
    AprilTagProcessor aprilTag;

    // Auto-heading PID
    static final double HEADING_KP = 0.01;
    static final double HEADING_KD = 0.002;
    static final double HEADING_DEADBAND = 1.2;
    static final double MAX_TURN_POWER = 0.5;
    double lastHeadingError = 0;
    long lastPidTime = 0;

    @Override
    public void runOpMode() {
        telemetry = new MultipleTelemetry(telemetry, FtcDashboard.getInstance().getTelemetry());

        // ===== HARDWARE MAP =====
        FL = hardwareMap.get(DcMotor.class, "CH_motor1");
        FR = hardwareMap.get(DcMotor.class, "CH_motor2");
        BL = hardwareMap.get(DcMotor.class, "CH_motor0");
        BR = hardwareMap.get(DcMotor.class, "CH_motor3");

        Shooter1 = hardwareMap.get(DcMotorEx.class, "EH_motor0");
        Shooter2 = hardwareMap.get(DcMotorEx.class, "EH_motor1");
        Intake   = hardwareMap.get(DcMotorEx.class, "EH_motor2");

        Transfer = hardwareMap.get(Servo.class, "EH_servo4");
        Hood     = hardwareMap.get(Servo.class, "EH_servo3");
        Spin     = hardwareMap.get(Servo.class, "EH_servo5");

        colorSensor = hardwareMap.get(RevColorSensorV3.class, "colorsensor1");

        BL.setDirection(DcMotorSimple.Direction.REVERSE);
        FL.setDirection(DcMotorSimple.Direction.REVERSE);
        Intake.setDirection(DcMotorSimple.Direction.REVERSE);

        for (DcMotor m : new DcMotor[]{FL, FR, BL, BR}) {
            m.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
            m.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        }

        Shooter1.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        Shooter2.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        Shooter1.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);
        Shooter2.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);

        Intake.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        Intake.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

        Transfer.setPosition(SERVO_IN);
        Hood.setPosition(0);

        // ===== SPINDEX + FSM =====
        spindex = new SpindexController();
        shooterFSM = new ShooterFSM();
        spindex.resetToIntake();

        // ===== CAMERA INIT =====
        aprilTag = new AprilTagProcessor.Builder().build();
        visionPortal = new VisionPortal.Builder()
                .setCamera(hardwareMap.get(WebcamName.class, "Webcam"))
                .addProcessor(aprilTag)
                .build();
        FtcDashboard.getInstance().startCameraStream(visionPortal, 30);

        waitForStart();
        shooterLastTime = System.nanoTime();
        lastPidTime = System.currentTimeMillis();

        while (opModeIsActive()) {
            // ===== DRIVE =====
            double drive = -gamepad1.left_stick_y;
            double strafe = gamepad1.left_stick_x;
            double rotate = gamepad1.right_stick_x;
            if (gamepad1.right_bumper) rotate += getAutoHeadingPID();

            double fl = drive + strafe + rotate;
            double fr = drive - strafe - rotate;
            double bl = drive - strafe + rotate;
            double br = drive + strafe - rotate;

            double max = Math.max(1.0, Math.max(Math.abs(fl),
                    Math.max(Math.abs(fr), Math.max(Math.abs(bl), Math.abs(br)))));
            FL.setPower(fl / max);
            FR.setPower(fr / max);
            BL.setPower(bl / max);
            BR.setPower(br / max);

            // ===== INPUTS =====
            boolean intakeOn = gamepad1.right_trigger > 0.2;
            boolean shooterA = gamepad1.left_trigger > 0.2;
            boolean shooterB = gamepad1.left_bumper;
            boolean shooterActive = shooterA || shooterB;

            // Select preset values
            double targetRPM = shooterA ? ShooterConfig.RPM_PRESET_A :
                               shooterB ? ShooterConfig.RPM_PRESET_B : 0;
            double hoodPos = shooterA ? ShooterConfig.HOOD_PRESET_A :
                             shooterB ? ShooterConfig.HOOD_PRESET_B : 0.0;

            Hood.setPosition(shooterActive ? hoodPos : 0.0);

            if (gamepad1.a && !lastA) spindex.resetToIntake();
            lastA = gamepad1.a;

            Intake.setPower(intakeOn ? 0.85 : 0);

            // ===== SHOOTER CONTROL =====
            double shooterRPM = (Shooter1.getVelocity() * 60.0) / (TICKS_PER_REV * GEAR_RATIO);
            double power = 0;

            if (shooterActive) {
                long now = System.nanoTime();
                double dt = (now - shooterLastTime) / 1e9;
                shooterLastTime = now;
                if (dt <= 0) dt = 0.02;

                double error = targetRPM - shooterRPM;

                // Bang-bang spinup
                if (error > ShooterConfig.bangBangRPM) {
                    power = 1.0;
                    shooterIntegral = 0;
                } else {
                    shooterIntegral += error * dt;
                    shooterIntegral = Math.max(-1500, Math.min(1500, shooterIntegral));
                    double derivative = (error - shooterLastError) / dt;
                    power = ShooterConfig.kP * error +
                            ShooterConfig.kI * shooterIntegral +
                            ShooterConfig.kD * derivative;
                    power = Math.max(0, Math.min(ShooterConfig.maxPower, power));
                    shooterLastError = error;
                }

                Shooter1.setPower(power);
                Shooter2.setPower(power);
            } else {
                Shooter1.setPower(0);
                Shooter2.setPower(0);
                shooterIntegral = 0;
                shooterLastError = 0;
            }

            boolean shooterReady = Math.abs(targetRPM - shooterRPM) < 80;

            // ===== COLOR SENSOR =====
            float[] hsv = new float[3];
            Color.RGBToHSV(colorSensor.red(), colorSensor.green(), colorSensor.blue(), hsv);
            boolean detectedBall = (hsv[0] > 140 && hsv[1] > 0.4 && hsv[2] > 0.2);

            if (intakeOn && detectedBall && !lastDetectedBall)
                spindex.nextIntakeSlot();
            lastDetectedBall = detectedBall;

            // ===== FSM UPDATE =====
            shooterFSM.requestShoot(shooterActive, shooterReady);
            spindex.update();
            shooterFSM.update();

            // ===== TELEMETRY =====
            telemetry.addData("RPM", shooterRPM);
            telemetry.addData("Target", targetRPM);
            telemetry.addData("Shooter Power", power);
            telemetry.addData("State", shooterFSM.state);
            telemetry.addData("Hood Pos", Hood.getPosition());
            telemetry.addData("Intake Slot", spindex.intakeIndex);
            telemetry.addData("Spindex Mode", spindex.mode);
            telemetry.update();
        }

        visionPortal.close();
    }

    // ================= SPINDEX =================
    class SpindexController {
        SpindexMode mode = SpindexMode.INTAKE;
        int intakeIndex = 0;
        int outtakeIndex = 0;
        boolean busy = false;
        long busyUntil = 0;

        void moveToSlot(int slot) { Spin.setPosition(SPINDEX_SLOTS[slot]); }

        void nextIntakeSlot() {
            if (busy || intakeIndex >= INTAKE_SLOTS.length - 1) return;
            intakeIndex++;
            moveToSlot(INTAKE_SLOTS[intakeIndex]);
            busy = true;
            busyUntil = System.currentTimeMillis() + SLOT_MOVE_DELAY;
        }

        void nextOuttakeSlot() {
            if (busy || outtakeIndex >= OUTTAKE_SLOTS.length) return;
            moveToSlot(OUTTAKE_SLOTS[outtakeIndex]);
            outtakeIndex++;
            busy = true;
            busyUntil = System.currentTimeMillis() + SLOT_MOVE_DELAY;
        }

        void update() { if (busy && System.currentTimeMillis() >= busyUntil) busy = false; }

        void resetToIntake() {
            mode = SpindexMode.INTAKE;
            intakeIndex = 0;
            outtakeIndex = 0;
            moveToSlot(INTAKE_SLOTS[0]);
            busy = false;
        }

        boolean outtakeDone() { return outtakeIndex >= OUTTAKE_SLOTS.length; }
    }

    // ================= SHOOTER FSM =================
    class ShooterFSM {
        ShooterState state = ShooterState.IDLE;
        long timer = 0;

        void requestShoot(boolean shooterHeld, boolean shooterReady) {
            if (!shooterHeld) {
                state = ShooterState.IDLE;
                Transfer.setPosition(SERVO_IN);
                spindex.resetToIntake();
                return;
            }

            if (state == ShooterState.IDLE && shooterReady) {
                spindex.mode = SpindexMode.OUTTAKE;
                spindex.outtakeIndex = 0;

                spindex.moveToSlot(OUTTAKE_SLOTS[0]);
                spindex.busy = true;
                spindex.busyUntil = System.currentTimeMillis() + SLOT_MOVE_DELAY;

                timer = System.currentTimeMillis();
                state = ShooterState.ARM_FIRST_SLOT;
            }
        }

        void update() {
            long now = System.currentTimeMillis();
            switch (state) {
                case ARM_FIRST_SLOT:
                    if (!spindex.busy) { timer = now; state = ShooterState.PRE_SHOT_DELAY; }
                    break;

                case PRE_SHOT_DELAY:
                    if (now - timer >= PRE_SHOT_DELAY) state = ShooterState.MOVE_TO_SLOT;
                    break;

                case MOVE_TO_SLOT:
                    if (!spindex.busy) {
                        if (spindex.outtakeDone()) state = ShooterState.IDLE;
                        else { spindex.nextOuttakeSlot(); state = ShooterState.WAIT_FOR_SPINDEX; }
                    }
                    break;

                case WAIT_FOR_SPINDEX:
                    if (!spindex.busy) { timer = now; state = ShooterState.SERVO_OUT; }
                    break;

                case SERVO_OUT:
                    Transfer.setPosition(SERVO_OUT);
                    if (now - timer >= SERVO_OUT_TIME) {
                        Transfer.setPosition(SERVO_IN);
                        timer = now;
                        state = ShooterState.SERVO_IN;
                    }
                    break;

                case SERVO_IN:
                    if (now - timer >= WAIT_BETWEEN_SHOTS) state = ShooterState.MOVE_TO_SLOT;
                    break;

                case IDLE: break;
            }
        }
    }

    // ================= AUTO-HEADING PID =================
    private double getAutoHeadingPID() {
        List<AprilTagDetection> detections = aprilTag.getDetections();
        if (detections.isEmpty()) return 0;
        double error = detections.get(0).ftcPose.bearing;
        if (Math.abs(error) < HEADING_DEADBAND) return 0;
        long now = System.currentTimeMillis();
        double dt = (now - lastPidTime) / 1000.0;
        if (dt <= 0) dt = 0.02;
        double derivative = (error - lastHeadingError) / dt;
        double output = error * HEADING_KP + derivative * HEADING_KD;
        output = Math.max(-MAX_TURN_POWER, Math.min(MAX_TURN_POWER, output));
        lastHeadingError = error;
        lastPidTime = now;
        return output;
    }

}